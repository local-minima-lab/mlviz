/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/dt/train_params": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Parameters
         * @description Gets the parameters for training.
         *
         *     Returns:
         *         List[ParameterInfo]: List of parameters for training
         */
        get: operations["get_parameters_api_dt_train_params_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dt/train": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Train Model
         * @description Train a decision tree model with the specified parameters.
         *
         *     Supports both predefined datasets (iris, wine, breast_cancer, digits)
         *     and custom datasets. Models are automatically cached for efficiency.
         *
         *     Args:
         *         request (DecisionTreeTrainingRequest): The request parameters
         *
         *     Raises:
         *         HTTPException: Exception if unable to train model
         *
         *     Returns:
         *         DecisionTreeTrainingResponse: Model details
         */
        post: operations["train_model_api_dt_train_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dt/predict_params": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Predict Params
         * @description Gets params for prediction
         *
         *     Args:
         *         request (DecisionTreeTrainingRequest): Request
         *
         *     Raises:
         *         HTTPException: Exception if retrieval failed
         *
         *     Returns:
         *         List[str]: Feature names
         */
        post: operations["get_predict_params_api_dt_predict_params_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dt/predict": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Predict With Instructions
         * @description Make a prediction and return traversal instructions for visualization.
         *
         *     This endpoint traverses the provided decision tree using the input feature
         *     values and returns:
         *     - The predicted class and confidence
         *     - A list of traversal instructions ("left", "right", "stop") that can be
         *       used by the frontend to animate the prediction path through the tree
         *
         *     Args:
         *         request: Contains the tree structure, feature values, and optional class names
         *
         *     Raises:
         *         HTTPException: If prediction fails (e.g., missing feature value)
         *
         *     Returns:
         *         DecisionTreeTraversalPredictResponse: Prediction result with instructions
         */
        post: operations["predict_with_instructions_api_dt_predict_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dt/cache": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear Cache
         * @description Clear all cached models.
         */
        delete: operations["clear_cache_api_dt_cache_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dt/cache/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Cache Info
         * @description Get cache statistics and information.
         */
        get: operations["get_cache_info_api_dt_cache_info_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dt/manual/node-stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Calculate Node Stats
         * @description Calculate statistics for a potential node split in manual tree building.
         *
         *     This endpoint calculates entropy/gini, information gain, class distributions,
         *     and histogram data for a given feature and threshold split.
         *
         *     Args:
         *         request (ManualNodeStatsRequest): Contains dataset, feature, threshold,
         *                                          parent samples mask, and criterion
         *
         *     Raises:
         *         HTTPException: If feature not found or calculation fails
         *
         *     Returns:
         *         ManualNodeStatsResponse: Statistics for parent and child nodes,
         *                                 information gain, histogram data, and sample masks
         */
        post: operations["calculate_node_stats_api_dt_manual_node_stats_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dt/manual/feature-stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Calculate Feature Stats
         * @description Calculate statistics for all possible thresholds of a feature.
         *
         *     This endpoint returns statistics for all valid split points of a feature,
         *     enabling instant slider feedback without additional API calls.
         *
         *     Args:
         *         request (ManualFeatureStatsRequest): Contains dataset, feature,
         *                                             parent samples mask, criterion,
         *                                             and max_thresholds limit
         *
         *     Raises:
         *         HTTPException: If feature not found, has only one value, or calculation fails
         *
         *     Returns:
         *         ManualFeatureStatsResponse: Array of threshold statistics, best threshold,
         *                                    feature range, histogram, and metadata
         */
        post: operations["calculate_feature_stats_api_dt_manual_feature_stats_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dt/manual/evaluate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Evaluate Manual Tree
         * @description Evaluate a manually built tree against test data.
         *
         *     This endpoint calculates accuracy, precision, recall, and F1 scores
         *     by making predictions on the test set using the provided tree structure.
         *
         *     Args:
         *         request (ManualTreeEvaluateRequest): Contains tree structure and optional dataset
         *
         *     Raises:
         *         HTTPException: If evaluation fails
         *
         *     Returns:
         *         ManualTreeEvaluateResponse: Metrics (accuracy, precision, recall, F1) and confusion matrix
         */
        post: operations["evaluate_manual_tree_api_dt_manual_evaluate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dataset/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Available Datasets
         * @description Get a list of all available predefined datasets.
         *
         *     Returns:
         *         DatasetListResponse: Dictionary of dataset names and their metadata
         */
        get: operations["get_available_datasets_api_dataset_list_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dataset/load": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Load Dataset
         * @description Load a dataset with its full data for visualization.
         *
         *     Defaults to the Iris dataset if no name is provided.
         *     Returns the complete dataset including feature values, labels,
         *     and metadata needed for visualization.
         *
         *     Args:
         *         name: Dataset name (defaults to "iris")
         *         test_size: Test set proportion (defaults to 0.25)
         *         random_state: Random seed (defaults to 2025)
         *
         *     Returns:
         *         DatasetResponse: Complete dataset with features, labels, and metadata
         *
         *     Raises:
         *         HTTPException: If dataset loading fails
         */
        get: operations["load_dataset_api_dataset_load_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/knn/params": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Parameters
         * @description Get the parameters for KNN.
         *
         *     Returns:
         *         List[ParameterInfo]: List of parameters for KNN
         */
        get: operations["get_parameters_api_knn_params_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/knn/predict": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Predict
         * @description Make KNN predictions with visualization data.
         *
         *     KNN is a lazy learner - no training phase needed. This endpoint
         *     fits the model on the provided dataset and makes predictions
         *     for the query points, returning neighbor information and
         *     decision boundary data for visualization.
         *
         *     Args:
         *         request (KNNPredictionRequest): Prediction request with parameters,
         *             dataset, and query points
         *
         *     Raises:
         *         HTTPException: If prediction fails
         *
         *     Returns:
         *         KNNPredictionResponse: Predictions, neighbor info, and visualization data
         */
        post: operations["predict_api_knn_predict_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/knn/visualise": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Visualise
         * @description Get KNN visualisation data without making predictions.
         *
         *     This endpoint is useful for visualising the training dataset
         *     with decision boundaries BEFORE making any predictions. It returns
         *     all training points and the decision boundary based on KNN parameters,
         *     but does not require any query points.
         *
         *     Use cases:
         *     - Initial dataset exploration
         *     - Understanding how K affects decision boundaries
         *     - Visualising feature spaces before prediction
         *
         *     Args:
         *         request (KNNVisualisationRequest): Visualisation request with parameters
         *             and dataset
         *
         *     Raises:
         *         HTTPException: If visualisation generation fails
         *
         *     Returns:
         *         KNNVisualisationResponse: Training data, decision boundary, and metadata
         */
        post: operations["visualise_api_knn_visualise_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/knn/train": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Train
         * @description Train KNN and return visualization data with evaluation metrics.
         *
         *     This endpoint:
         *     1. Splits dataset into train/test sets (80/20)
         *     2. Trains KNN on training set
         *     3. Evaluates on test set (confusion matrix + scores)
         *     4. Generates visualization data (decision boundary, etc.)
         *
         *     Use this endpoint for TrainPage to get both visualization and metrics.
         *     Use /visualise for VizOnlyPage (no metrics needed).
         *
         *     Args:
         *         request: Training request with parameters and dataset
         *
         *     Raises:
         *         HTTPException: If training fails
         *
         *     Returns:
         *         KNNTrainingResponse: Visualization data + evaluation metrics
         */
        post: operations["train_api_knn_train_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/kmeans/params": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Parameters
         * @description Get the parameters for K-Means.
         *
         *     Returns:
         *         List[ParameterInfo]: List of parameters for K-Means
         */
        get: operations["get_parameters_api_kmeans_params_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/kmeans/step": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Step
         * @description Perform one K-Means iteration: assign points to centroids and update centroids.
         *
         *     This endpoint takes user-provided centroids and:
         *     1. Assigns each data point to its nearest centroid
         *     2. Calculates new centroid positions as the mean of assigned points
         *     3. Returns all data needed for visualization
         *
         *     Use this for step-by-step K-Means visualization where users can:
         *     - Place initial centroids manually
         *     - Step through iterations one at a time
         *     - Observe how clusters evolve
         *
         *     Args:
         *         request: Step request with parameters, centroids, and dataset
         *
         *     Raises:
         *         HTTPException: If step fails
         *
         *     Returns:
         *         KMeansStepResponse: Assignments, distances, updated centroids, and visualization data
         */
        post: operations["step_api_kmeans_step_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/kmeans/train": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Train
         * @description Run K-Means until convergence, returning all iterations.
         *
         *     This endpoint takes user-provided initial centroids and:
         *     1. Runs K-Means iterations until convergence or max_iterations
         *     2. Returns data for ALL iterations for playback/animation
         *     3. Includes final results
         *
         *     Use this when you want to:
         *     - Animate the full K-Means algorithm
         *     - Show convergence behavior
         *     - Get final clustering results
         *
         *     Args:
         *         request: Training request with parameters, initial centroids, dataset, and max_iterations
         *
         *     Raises:
         *         HTTPException: If training fails
         *
         *     Returns:
         *         KMeansTrainResponse: All iterations, final centroids, and visualization data
         */
        post: operations["train_api_kmeans_train_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/kmeans/predict": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Predict
         * @description Predict cluster assignments for query points given centroids.
         *
         *     This endpoint assigns query points to their nearest centroid
         *     and returns distance information for visualization.
         *
         *     Args:
         *         request: Prediction request with parameters, centroids, and query points
         *
         *     Raises:
         *         HTTPException: If prediction fails
         *
         *     Returns:
         *         KMeansPredictResponse: Assignments and distances for query points
         */
        post: operations["predict_api_kmeans_predict_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Health Check
         * @description Health check endpoint.
         */
        get: operations["health_check_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AnyParameterInfo
         * @description Any type parameter.
         */
        AnyParameterInfo: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Default */
            default: unknown;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "any";
        };
        /**
         * CacheInfoResponse
         * @description Response model for cache information.
         */
        CacheInfoResponse: {
            /** Enabled */
            enabled: boolean;
            /** Current Size */
            current_size: number;
            /** Max Size */
            max_size: number;
            /** Keys */
            keys: string[] | string;
        };
        /**
         * ClassificationMetadata
         * @description Metadata for classifier responses.
         */
        ClassificationMetadata: {
            /** Feature Names */
            feature_names: string[];
            /** Class Names */
            class_names: string[];
            /** N Features */
            n_features: number;
            /** N Classes */
            n_classes: number;
            /** Dataset Name */
            dataset_name?: string | null;
        };
        /** ClassificationMetrics */
        ClassificationMetrics: {
            /** Confusion Matrix */
            confusion_matrix: number[][];
            /** Accuracy */
            accuracy: number;
            /** Precision */
            precision: number;
            /** Recall */
            recall: number;
            /** F1 */
            f1: number;
        };
        /**
         * Dataset
         * @description Complete dataset with features and targets.
         */
        Dataset: {
            /**
             * X
             * @description Feature matrix
             */
            X: number[][];
            /**
             * Y
             * @description Target vector
             */
            y: number[];
            /** Feature Names */
            feature_names?: string[] | null;
            /** Target Names */
            target_names?: string[] | null;
            info?: components["schemas"]["DatasetInfo"] | null;
            /**
             * Test Size
             * @default 0.25
             */
            test_size: number;
            /**
             * Random State
             * @default 2025
             */
            random_state: number;
        };
        /**
         * DatasetInfo
         * @description Metadata about a dataset.
         */
        DatasetInfo: {
            /** Name */
            name: string;
            /** Description */
            description?: string | null;
            /** N Samples */
            n_samples: number;
            /** N Features */
            n_features: number;
            /** N Classes */
            n_classes: number;
            /**
             * Target Type
             * @default classification
             * @enum {string}
             */
            target_type: "classification" | "regression";
        };
        /**
         * DatasetListResponse
         * @description Response model for available datasets.
         */
        DatasetListResponse: {
            /** Datasets */
            datasets: {
                [key: string]: components["schemas"]["DatasetInfo"];
            };
        };
        /**
         * DatasetResponse
         * @description Response model for loaded dataset.
         */
        DatasetResponse: {
            /** Success */
            success: boolean;
            /**
             * X
             * @description Feature matrix
             */
            X: number[][];
            /**
             * Y
             * @description Target vector
             */
            y: number[];
            /**
             * Feature Names
             * @description Names of features
             */
            feature_names: string[];
            /**
             * Target Names
             * @description Names of target classes
             */
            target_names: string[];
            /** @description Dataset metadata */
            info: components["schemas"]["DatasetInfo"];
            /**
             * Test Size
             * @description Test set proportion
             */
            test_size: number;
            /**
             * Random State
             * @description Random seed for reproducibility
             */
            random_state: number;
        };
        /**
         * DecisionBoundaryData
         * @description Decision boundary visualization data.
         */
        DecisionBoundaryData: {
            /**
             * Mesh Points
             * @description Grid points for boundary visualization
             */
            mesh_points: number[][];
            /**
             * Predictions
             * @description Predicted class at each mesh point
             */
            predictions: string[];
            /**
             * Dimensions
             * @description Number of dimensions (1, 2, or 3)
             */
            dimensions: number;
        };
        /**
         * DecisionTreeTrainingRequest
         * @description Request model for Decision Tree.
         */
        DecisionTreeTrainingRequest: {
            /**
             * Max Depth
             * @description Maximum depth of the tree
             * @default 5
             */
            max_depth: number | null;
            /**
             * Criterion
             * @description Split quality criterion
             * @default gini
             * @enum {string}
             */
            criterion: "gini" | "entropy";
            /**
             * Min Samples Split
             * @description Minimum samples to split
             * @default 2
             */
            min_samples_split: number | null;
            /**
             * Min Samples Leaf
             * @description Minimum samples at leaf
             * @default 1
             */
            min_samples_leaf: number | null;
            /**
             * Max Features
             * @description Number of features to consider
             */
            max_features?: ("sqrt" | "log2") | null;
            /**
             * Random State
             * @description Random seed for reproducibility
             * @default 2025
             */
            random_state: number | null;
            /**
             * Dataset
             * @description Dataset to use for training
             */
            dataset?: components["schemas"]["Dataset"] | components["schemas"]["PredefinedDataset"] | null;
        };
        /**
         * DecisionTreeTrainingResponse
         * @description Response model for Decision Tree.
         */
        DecisionTreeTrainingResponse: {
            /** Success */
            success: boolean;
            /** Model Key */
            model_key: string;
            /** Cached */
            cached: boolean;
            metadata: components["schemas"]["ClassificationMetadata"];
            /** Tree */
            tree: components["schemas"]["SplitNode-Output"] | components["schemas"]["LeafNode"];
            metrics: components["schemas"]["ClassificationMetrics"];
        };
        /**
         * DecisionTreeTraversalPredictRequest
         * @description Request for decision tree prediction with traversal instructions.
         */
        DecisionTreeTraversalPredictRequest: {
            /**
             * Tree
             * @description Root node of the decision tree
             */
            tree: components["schemas"]["SplitNode-Input"] | components["schemas"]["LeafNode"];
            /**
             * Points
             * @description Feature name to value mapping for prediction
             */
            points: {
                [key: string]: number;
            };
            /**
             * Class Names
             * @description Class names for the prediction result (optional)
             */
            class_names?: string[] | null;
        };
        /**
         * DecisionTreeTraversalPredictResponse
         * @description Response containing prediction result with traversal instructions.
         */
        DecisionTreeTraversalPredictResponse: {
            /**
             * Predicted Class
             * @description Predicted class label
             */
            predicted_class: string;
            /**
             * Predicted Class Index
             * @description Index of the predicted class
             */
            predicted_class_index: number;
            /**
             * Confidence
             * @description Confidence score (proportion of samples at leaf)
             */
            confidence: number;
            /**
             * Instructions
             * @description Traversal instructions from root to leaf
             */
            instructions: ("left" | "right" | "stop")[];
        };
        /**
         * FloatParameterInfo
         * @description Float parameter with optional range and step.
         */
        FloatParameterInfo: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Default */
            default: unknown;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "float";
            /** Min */
            min?: number | null;
            /** Max */
            max?: number | null;
            /** Step */
            step?: number | null;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /** HistogramData */
        HistogramData: {
            /** Feature Values */
            feature_values: number[];
            /** Class Labels */
            class_labels: number[];
            /** Bins */
            bins: number[];
            /** Counts By Class */
            counts_by_class: {
                [key: string]: number[];
            };
            /** Threshold */
            threshold: number | null;
            /** Total Samples */
            total_samples: number;
        };
        /**
         * IntParameterInfo
         * @description Integer parameter with optional range.
         */
        IntParameterInfo: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Default */
            default: unknown;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "int";
            /** Min */
            min?: number | null;
            /** Max */
            max?: number | null;
        };
        /**
         * KMeansClusterInfo
         * @description Information about a single cluster.
         */
        KMeansClusterInfo: {
            /** Cluster Id */
            cluster_id: number;
            /** Centroid */
            centroid: number[];
            /** N Points */
            n_points: number;
            /** Point Indices */
            point_indices: number[];
        };
        /**
         * KMeansIterationData
         * @description Data for a single K-Means iteration.
         */
        KMeansIterationData: {
            /**
             * Iteration
             * @description Iteration number (0-indexed)
             */
            iteration: number;
            /**
             * Assignments
             * @description Cluster index for each data point
             */
            assignments: number[];
            /**
             * Distance Matrix
             * @description Distance from each point to each centroid
             */
            distance_matrix: number[][];
            /**
             * Centroids
             * @description Centroids at start of iteration
             */
            centroids: number[][];
            /**
             * New Centroids
             * @description Updated centroids after iteration
             */
            new_centroids: number[][];
            /**
             * Centroid Shifts
             * @description Distance each centroid moved
             */
            centroid_shifts: number[];
            /**
             * Converged
             * @description Whether converged at this iteration
             */
            converged: boolean;
            /**
             * Cluster Info
             * @description Detailed information for each cluster
             */
            cluster_info: components["schemas"]["KMeansClusterInfo"][];
        };
        /**
         * KMeansMetadata
         * @description Metadata for K-Means clustering.
         */
        KMeansMetadata: {
            /** Feature Names */
            feature_names: string[];
            /** N Features */
            n_features: number;
            /** N Samples */
            n_samples: number;
            /** N Clusters */
            n_clusters: number;
        };
        /**
         * KMeansParameters
         * @description Core K-Means algorithm parameters for manual step-by-step clustering.
         */
        KMeansParameters: {
            /**
             * N Clusters
             * @description Number of clusters to form
             * @default 3
             */
            n_clusters: number;
            /**
             * Metric
             * @description Distance metric for assigning points to clusters
             * @default euclidean
             * @enum {string}
             */
            metric: "euclidean" | "manhattan";
            /**
             * Feature 1
             * @description First feature index for visualization
             * @default 0
             */
            feature_1: number;
            /**
             * Feature 2
             * @description Second feature index for visualization
             * @default 1
             */
            feature_2: number | null;
        };
        /**
         * KMeansPredictRequest
         * @description Request model for K-Means prediction.
         */
        KMeansPredictRequest: {
            /** @description K-Means algorithm parameters */
            parameters?: components["schemas"]["KMeansParameters"];
            /**
             * Centroids
             * @description Centroid positions [[x, y], ...]
             */
            centroids: number[][];
            /**
             * Query Points
             * @description Points to assign to clusters [[x, y], ...]
             */
            query_points: number[][];
        };
        /**
         * KMeansPredictResponse
         * @description Response model for K-Means prediction.
         */
        KMeansPredictResponse: {
            /** Success */
            success: boolean;
            /**
             * Query Points
             * @description The input points
             */
            query_points: number[][];
            /**
             * Assignments
             * @description Cluster index for each query point
             */
            assignments: number[];
            /**
             * Distance Matrix
             * @description Distance from each query point to each centroid
             */
            distance_matrix: number[][];
            /**
             * Assigned Distances
             * @description Distance to the assigned centroid for each point
             */
            assigned_distances: number[];
            /**
             * Centroids
             * @description The centroids used
             */
            centroids: number[][];
        };
        /**
         * KMeansStepRequest
         * @description Request model for a single K-Means iteration.
         */
        KMeansStepRequest: {
            /** @description K-Means algorithm parameters */
            parameters?: components["schemas"]["KMeansParameters"];
            /**
             * Centroids
             * @description Current centroid positions [[x, y], ...]
             */
            centroids: number[][];
            /**
             * Dataset
             * @description Dataset to use. Defaults to Iris dataset.
             */
            dataset?: components["schemas"]["Dataset"] | components["schemas"]["PredefinedDataset"] | null;
            /**
             * Visualisation Features
             * @description Feature indices for visualization (defaults to [feature_1, feature_2])
             */
            visualisation_features?: number[] | null;
        };
        /**
         * KMeansStepResponse
         * @description Response model for a single K-Means iteration.
         */
        KMeansStepResponse: {
            /** Success */
            success: boolean;
            /**
             * Data Points
             * @description All data points in visualization space
             */
            data_points: number[][];
            /**
             * Assignments
             * @description Cluster index for each data point
             */
            assignments: number[];
            /**
             * Distance Matrix
             * @description Distance from each point to each centroid
             */
            distance_matrix: number[][];
            /**
             * Centroids
             * @description Original centroids passed in
             */
            centroids: number[][];
            /**
             * New Centroids
             * @description Updated centroids after iteration
             */
            new_centroids: number[][];
            /**
             * Centroid Shifts
             * @description Distance each centroid moved
             */
            centroid_shifts: number[];
            /**
             * Converged
             * @description Whether the algorithm has converged
             */
            converged: boolean;
            /**
             * Cluster Info
             * @description Detailed information for each cluster
             */
            cluster_info: components["schemas"]["KMeansClusterInfo"][];
            metadata: components["schemas"]["KMeansMetadata"];
            /** Visualisation Feature Indices */
            visualisation_feature_indices: number[];
            /** Visualisation Feature Names */
            visualisation_feature_names: string[];
        };
        /**
         * KMeansTrainRequest
         * @description Request model for K-Means training (all iterations).
         */
        KMeansTrainRequest: {
            /** @description K-Means algorithm parameters */
            parameters?: components["schemas"]["KMeansParameters"];
            /**
             * Centroids
             * @description Initial centroid positions [[x, y], ...]
             */
            centroids: number[][];
            /**
             * Dataset
             * @description Dataset to use. Defaults to Iris dataset.
             */
            dataset?: components["schemas"]["Dataset"] | components["schemas"]["PredefinedDataset"] | null;
            /**
             * Visualisation Features
             * @description Feature indices for visualization (defaults to [feature_1, feature_2])
             */
            visualisation_features?: number[] | null;
            /**
             * Max Iterations
             * @description Maximum iterations before stopping
             * @default 100
             */
            max_iterations: number;
        };
        /**
         * KMeansTrainResponse
         * @description Response model for K-Means training (all iterations until convergence).
         */
        KMeansTrainResponse: {
            /** Success */
            success: boolean;
            /**
             * Data Points
             * @description All data points in visualization space
             */
            data_points: number[][];
            /**
             * Iterations
             * @description Data for each iteration
             */
            iterations: components["schemas"]["KMeansIterationData"][];
            /**
             * Total Iterations
             * @description Total number of iterations run
             */
            total_iterations: number;
            /**
             * Converged
             * @description Whether the algorithm converged
             */
            converged: boolean;
            /**
             * Final Centroids
             * @description Final centroid positions
             */
            final_centroids: number[][];
            /**
             * Final Assignments
             * @description Final cluster assignments
             */
            final_assignments: number[];
            metadata: components["schemas"]["KMeansMetadata"];
            /** Visualisation Feature Indices */
            visualisation_feature_indices: number[];
            /** Visualisation Feature Names */
            visualisation_feature_names: string[];
        };
        /**
         * KNNParameters
         * @description Core KNN algorithm parameters matching sklearn.neighbors.KNeighborsClassifier.
         */
        KNNParameters: {
            /**
             * N Neighbors
             * @description Number of neighbors to use
             * @default 5
             */
            n_neighbors: number;
            /**
             * Weights
             * @description Weight function: 'uniform' (equal weights) or 'distance' (inverse distance weighting)
             * @default uniform
             * @enum {string}
             */
            weights: "uniform" | "distance";
            /**
             * Algorithm
             * @description Algorithm to compute nearest neighbors
             * @default auto
             * @enum {string}
             */
            algorithm: "auto" | "ball_tree" | "kd_tree" | "brute";
            /**
             * Leaf Size
             * @description Leaf size passed to BallTree or KDTree (affects speed and memory)
             * @default 30
             */
            leaf_size: number;
            /**
             * P
             * @description Power parameter for Minkowski metric (p=1: Manhattan, p=2: Euclidean)
             * @default 2
             */
            p: number;
            /**
             * Metric
             * @description Distance metric to use
             * @default minkowski
             * @enum {string}
             */
            metric: "minkowski" | "euclidean" | "manhattan" | "chebyshev";
            /**
             * Feature 1
             * @description First feature index for training and visualization
             * @default 0
             */
            feature_1: number;
            /**
             * Feature 2
             * @description Second feature index for training and visualization (optional)
             * @default 1
             */
            feature_2: number | null;
        };
        /**
         * KNNPredictionRequest
         * @description Request model for KNN prediction.
         */
        KNNPredictionRequest: {
            /** @description KNN algorithm parameters (defaults to n_neighbors=5, uniform weights, etc.) */
            parameters?: components["schemas"]["KNNParameters"];
            /**
             * Dataset
             * @description Training dataset with X, y, feature_names, class_names. Defaults to Iris dataset.
             */
            dataset?: components["schemas"]["Dataset"] | components["schemas"]["PredefinedDataset"] | null;
            /**
             * Query Points
             * @description Test points to classify
             */
            query_points: number[][];
            /**
             * Visualisation Features
             * @description Indices for visualisation features
             */
            visualisation_features?: number[] | null;
            /**
             * Include Boundary
             * @description Whether to include decision boundary data
             * @default true
             */
            include_boundary: boolean;
            /**
             * Boundary Resolution
             * @description Resolution of boundary mesh
             * @default 50
             */
            boundary_resolution: number;
        };
        /**
         * KNNPredictionResponse
         * @description Response model for KNN prediction.
         */
        KNNPredictionResponse: {
            /** Success */
            success: boolean;
            /**
             * Predictions
             * @description Predicted class labels
             */
            predictions: string[];
            /**
             * Prediction Indices
             * @description Predicted class indices
             */
            prediction_indices: number[];
            /**
             * Neighbors Info
             * @description Neighbor information for each query point
             */
            neighbors_info: components["schemas"]["NeighborInfo"][][];
            /**
             * Training Points
             * @description All training point coordinates
             */
            training_points: number[][];
            /**
             * Training Labels
             * @description All training point labels
             */
            training_labels: string[];
            /**
             * All Distances
             * @description Distance from each query point to all training points
             */
            all_distances: number[][];
            /**
             * Distance Matrix
             * @description Distance from each training point to all other training points (0 for self)
             */
            distance_matrix: number[][];
            /**
             * Neighbor Indices
             * @description Indices of K nearest neighbors for each training point (sorted by distance)
             */
            neighbor_indices: number[][];
            /** @description Decision boundary visualization data */
            decision_boundary?: components["schemas"]["DecisionBoundaryData"] | null;
            /** Feature Names */
            feature_names: string[];
            /** Class Names */
            class_names: string[];
            /** N Dimensions */
            n_dimensions: number;
        };
        /**
         * KNNTrainingRequest
         * @description Request model for KNN training with evaluation.
         */
        KNNTrainingRequest: {
            /** @description KNN algorithm parameters */
            parameters?: components["schemas"]["KNNParameters"];
            /**
             * Dataset
             * @description Training dataset. Defaults to Iris dataset.
             */
            dataset?: components["schemas"]["Dataset"] | components["schemas"]["PredefinedDataset"] | null;
            /**
             * Visualisation Features
             * @description Feature indices to visualise (1-3 features)
             */
            visualisation_features?: number[] | null;
            /**
             * Include Boundary
             * @description Whether to include decision boundary
             * @default true
             */
            include_boundary: boolean;
            /**
             * Boundary Resolution
             * @description Resolution of boundary mesh
             * @default 50
             */
            boundary_resolution: number;
        };
        /**
         * KNNTrainingResponse
         * @description Response model for KNN training with evaluation metrics.
         */
        KNNTrainingResponse: {
            /** Success */
            success: boolean;
            /** Training Points */
            training_points: number[][];
            /** Training Labels */
            training_labels: string[];
            /** Distance Matrix */
            distance_matrix: number[][];
            /** Neighbor Indices */
            neighbor_indices: number[][];
            decision_boundary: components["schemas"]["DecisionBoundaryData"] | null;
            /** @description Classifier metadata */
            metadata: components["schemas"]["ClassificationMetadata"];
            /** Visualisation Feature Indices */
            visualisation_feature_indices: number[] | null;
            /** Visualisation Feature Names */
            visualisation_feature_names: string[] | null;
            /** @description Classification metrics including confusion matrix and scores */
            metrics: components["schemas"]["ClassificationMetrics"];
        };
        /**
         * KNNVisualisationRequest
         * @description Request model for KNN visualisation without prediction.
         */
        KNNVisualisationRequest: {
            /** @description KNN algorithm parameters */
            parameters?: components["schemas"]["KNNParameters"];
            /**
             * Dataset
             * @description Training dataset. Defaults to Iris dataset.
             */
            dataset?: components["schemas"]["Dataset"] | components["schemas"]["PredefinedDataset"] | null;
            /**
             * Visualisation Features
             * @description Feature indices to visualise (1-3 features)
             */
            visualisation_features?: number[] | null;
            /**
             * Include Boundary
             * @description Whether to include decision boundary
             * @default true
             */
            include_boundary: boolean;
            /**
             * Boundary Resolution
             * @description Resolution of boundary mesh
             * @default 50
             */
            boundary_resolution: number;
        };
        /**
         * KNNVisualisationResponse
         * @description Response model for KNN visualisation without prediction.
         */
        KNNVisualisationResponse: {
            /** Success */
            success: boolean;
            /**
             * Training Points
             * @description All training point coordinates (visualisation features only)
             */
            training_points: number[][];
            /**
             * Training Labels
             * @description All training point labels
             */
            training_labels: string[];
            /**
             * Distance Matrix
             * @description Distance from each training point to all other training points (0 for self)
             */
            distance_matrix: number[][];
            /**
             * Neighbor Indices
             * @description Indices of K nearest neighbors for each training point (sorted by distance)
             */
            neighbor_indices: number[][];
            /** @description Decision boundary visualisation data */
            decision_boundary?: components["schemas"]["DecisionBoundaryData"] | null;
            /** @description Classifier metadata */
            metadata: components["schemas"]["ClassificationMetadata"];
            /**
             * Visualisation Feature Indices
             * @description Feature indices used for visualisation
             */
            visualisation_feature_indices?: number[] | null;
            /**
             * Visualisation Feature Names
             * @description Names of features used for visualisation
             */
            visualisation_feature_names?: string[] | null;
        };
        /**
         * LeafNode
         * @description Leaf node in a decision tree (no further splits).
         */
        LeafNode: {
            /** Samples */
            samples: number;
            /** Impurity */
            impurity: number;
            /** Value */
            value: number[][];
            /**
             * Samples Mask
             * @description Indices of samples that reached this node (None for trained models, populated for manual trees)
             */
            samples_mask?: number[] | null;
            /**
             * Terminal
             * @description Whether this node is marked as terminal (frontend-only, used in manual tree building)
             */
            terminal?: boolean | null;
            /**
             * Type
             * @default leaf
             * @constant
             */
            type: "leaf";
        };
        /**
         * ManualFeatureStatsRequest
         * @description Request to calculate statistics for all thresholds of a feature.
         */
        ManualFeatureStatsRequest: {
            /**
             * Feature
             * @description Feature name to analyze
             */
            feature: string;
            /**
             * Parent Samples Mask
             * @description Indices of samples that reached this node (None for root)
             */
            parent_samples_mask?: number[] | null;
            /**
             * Criterion
             * @description Criterion to use for impurity calculation (gini or entropy)
             * @default gini
             */
            criterion: string;
            /**
             * Max Thresholds
             * @description Maximum number of thresholds to return
             * @default 100
             */
            max_thresholds: number;
            /**
             * Dataset
             * @description Dataset to use for training
             */
            dataset?: components["schemas"]["Dataset"] | components["schemas"]["PredefinedDataset"] | null;
        };
        /**
         * ManualFeatureStatsResponse
         * @description Response containing statistics for all thresholds of a feature.
         */
        ManualFeatureStatsResponse: {
            /** Feature */
            feature: string;
            /** Feature Index */
            feature_index: number;
            /**
             * Thresholds
             * @description Statistics for each threshold, sorted by threshold value
             */
            thresholds: components["schemas"]["ThresholdStatistics"][];
            /**
             * Best Threshold
             * @description Threshold with highest information gain
             */
            best_threshold: number;
            /**
             * Best Threshold Index
             * @description Index of best threshold in the thresholds array
             */
            best_threshold_index: number;
            /**
             * Feature Range
             * @description [min, max] values of the feature
             */
            feature_range: number[];
            /** @description Overall feature distribution at current node */
            histogram_data: components["schemas"]["HistogramData"];
            /**
             * Total Unique Values
             * @description Total number of unique feature values
             */
            total_unique_values: number;
            /**
             * Returned Threshold Count
             * @description Number of thresholds returned (may be capped)
             */
            returned_threshold_count: number;
            /**
             * Available Features
             * @description List of all available features
             */
            available_features: string[];
            /**
             * Class Names
             * @description List of all class names in the dataset
             */
            class_names: string[];
        };
        /**
         * ManualNodeStatsRequest
         * @description Request to calculate statistics for a potential node split.
         */
        ManualNodeStatsRequest: {
            /**
             * Feature
             * @description Feature name to split on
             */
            feature: string;
            /**
             * Threshold
             * @description Threshold value for the split
             */
            threshold: number;
            /**
             * Parent Samples Mask
             * @description Indices of samples that reached this node (None for root)
             */
            parent_samples_mask?: number[] | null;
            /**
             * Criterion
             * @description Criterion to use for impurity calculation (gini or entropy)
             * @default gini
             */
            criterion: string;
            /**
             * Dataset
             * @description Dataset to use for training
             */
            dataset?: components["schemas"]["Dataset"] | components["schemas"]["PredefinedDataset"] | null;
        };
        /**
         * ManualNodeStatsResponse
         * @description Response containing statistics for a potential split.
         */
        ManualNodeStatsResponse: {
            /** Feature */
            feature: string;
            /** Feature Index */
            feature_index: number;
            /** Threshold */
            threshold: number;
            split_stats: components["schemas"]["SplitStatistics"];
            histogram_data: components["schemas"]["HistogramData"];
            /**
             * Left Samples Mask
             * @description Indices of samples that go to left child (<= threshold)
             */
            left_samples_mask: number[];
            /**
             * Right Samples Mask
             * @description Indices of samples that go to right child (> threshold)
             */
            right_samples_mask: number[];
            /**
             * Available Features
             * @description List of all available features
             */
            available_features: string[];
            /**
             * Class Names
             * @description List of all class names in the dataset
             */
            class_names: string[];
        };
        /**
         * ManualTreeEvaluateRequest
         * @description Request to evaluate a manually built tree.
         */
        ManualTreeEvaluateRequest: {
            /**
             * Tree
             * @description Root node of the manual tree
             */
            tree: components["schemas"]["SplitNode-Input"] | components["schemas"]["LeafNode"];
            /**
             * Dataset
             * @description Dataset to use for evaluation (defaults to Iris)
             */
            dataset?: components["schemas"]["Dataset"] | components["schemas"]["PredefinedDataset"] | null;
        };
        /**
         * ManualTreeEvaluateResponse
         * @description Response containing evaluation metrics for a manual tree.
         */
        ManualTreeEvaluateResponse: {
            /** @description Classification metrics including confusion matrix and scores */
            metrics: components["schemas"]["ClassificationMetrics"];
            /** @description Classifier metadata including feature and class information */
            metadata: components["schemas"]["ClassificationMetadata"];
        };
        /**
         * NeighborInfo
         * @description Information about a single neighbor.
         */
        NeighborInfo: {
            /**
             * Index
             * @description Index in training data
             */
            index: number;
            /**
             * Distance
             * @description Distance from query point
             */
            distance: number;
            /**
             * Label
             * @description Class label
             */
            label: string;
            /**
             * Coordinates
             * @description Feature values
             */
            coordinates: number[];
        };
        /**
         * NodeStatistics
         * @description Statistics for a node before/after split.
         */
        NodeStatistics: {
            /** Samples */
            samples: number;
            /** Impurity */
            impurity: number;
            /** Class Distribution */
            class_distribution: {
                [key: string]: number;
            };
            /** Class Probabilities */
            class_probabilities: {
                [key: string]: number;
            };
        };
        /**
         * NumberParameterInfo
         * @description Number parameter with optional range and step.
         */
        NumberParameterInfo: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Default */
            default: unknown;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "number";
            /** Min */
            min?: number | null;
            /** Max */
            max?: number | null;
            /** Step */
            step?: number | null;
        };
        /**
         * PredefinedDataset
         * @description Reference to a predefined dataset.
         */
        PredefinedDataset: {
            /**
             * Name
             * @enum {string}
             */
            name: "iris" | "wine" | "breast_cancer" | "digits";
            /**
             * Test Size
             * @default 0.25
             */
            test_size: number;
            /**
             * Random State
             * @default 2025
             */
            random_state: number;
        };
        /**
         * SelectParameterInfo
         * @description Select parameter with predefined options.
         */
        SelectParameterInfo: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Default */
            default: unknown;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "select";
            /** Options */
            options: unknown[] | string;
        };
        /**
         * SplitNode
         * @description Binary split node in a decision tree.
         */
        "SplitNode-Input": {
            /** Samples */
            samples: number;
            /** Impurity */
            impurity: number;
            /** Value */
            value: number[][];
            /**
             * Samples Mask
             * @description Indices of samples that reached this node (None for trained models, populated for manual trees)
             */
            samples_mask?: number[] | null;
            /**
             * Terminal
             * @description Whether this node is marked as terminal (frontend-only, used in manual tree building)
             */
            terminal?: boolean | null;
            /**
             * Type
             * @default split
             * @constant
             */
            type: "split";
            /** Feature */
            feature: string;
            /**
             * Feature Index
             * @description Numeric index of the feature (None for manual trees, populated for trained models)
             */
            feature_index?: number | null;
            /** Threshold */
            threshold: number;
            histogram_data?: components["schemas"]["HistogramData"] | null;
            /** Left */
            left: components["schemas"]["SplitNode-Input"] | components["schemas"]["LeafNode"];
            /** Right */
            right: components["schemas"]["SplitNode-Input"] | components["schemas"]["LeafNode"];
        };
        /**
         * SplitNode
         * @description Binary split node in a decision tree.
         */
        "SplitNode-Output": {
            /** Samples */
            samples: number;
            /** Impurity */
            impurity: number;
            /** Value */
            value: number[][];
            /**
             * Samples Mask
             * @description Indices of samples that reached this node (None for trained models, populated for manual trees)
             */
            samples_mask?: number[] | null;
            /**
             * Terminal
             * @description Whether this node is marked as terminal (frontend-only, used in manual tree building)
             */
            terminal?: boolean | null;
            /**
             * Type
             * @default split
             * @constant
             */
            type: "split";
            /** Feature */
            feature: string;
            /**
             * Feature Index
             * @description Numeric index of the feature (None for manual trees, populated for trained models)
             */
            feature_index?: number | null;
            /** Threshold */
            threshold: number;
            histogram_data?: components["schemas"]["HistogramData"] | null;
            /** Left */
            left: components["schemas"]["SplitNode-Output"] | components["schemas"]["LeafNode"];
            /** Right */
            right: components["schemas"]["SplitNode-Output"] | components["schemas"]["LeafNode"];
        };
        /**
         * SplitStatistics
         * @description Statistics for evaluating a split.
         */
        SplitStatistics: {
            parent_stats: components["schemas"]["NodeStatistics"];
            left_stats: components["schemas"]["NodeStatistics"];
            right_stats: components["schemas"]["NodeStatistics"];
            /** Information Gain */
            information_gain: number;
            /** Weighted Impurity */
            weighted_impurity: number;
        };
        /**
         * ThresholdStatistics
         * @description Statistics for a single threshold value.
         */
        ThresholdStatistics: {
            /** Threshold */
            threshold: number;
            /** Information Gain */
            information_gain: number;
            split_stats: components["schemas"]["SplitStatistics"];
            /**
             * Left Samples Mask
             * @description Indices of samples that go to left child (<= threshold)
             */
            left_samples_mask: number[];
            /**
             * Right Samples Mask
             * @description Indices of samples that go to right child (> threshold)
             */
            right_samples_mask: number[];
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    get_parameters_api_dt_train_params_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": (components["schemas"]["SelectParameterInfo"] | components["schemas"]["IntParameterInfo"] | components["schemas"]["NumberParameterInfo"] | components["schemas"]["FloatParameterInfo"] | components["schemas"]["AnyParameterInfo"])[];
                };
            };
        };
    };
    train_model_api_dt_train_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DecisionTreeTrainingRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DecisionTreeTrainingResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_predict_params_api_dt_predict_params_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DecisionTreeTrainingRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string[];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    predict_with_instructions_api_dt_predict_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DecisionTreeTraversalPredictRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DecisionTreeTraversalPredictResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    clear_cache_api_dt_cache_delete: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    get_cache_info_api_dt_cache_info_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CacheInfoResponse"];
                };
            };
        };
    };
    calculate_node_stats_api_dt_manual_node_stats_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ManualNodeStatsRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ManualNodeStatsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    calculate_feature_stats_api_dt_manual_feature_stats_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ManualFeatureStatsRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ManualFeatureStatsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    evaluate_manual_tree_api_dt_manual_evaluate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ManualTreeEvaluateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ManualTreeEvaluateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_available_datasets_api_dataset_list_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatasetListResponse"];
                };
            };
        };
    };
    load_dataset_api_dataset_load_get: {
        parameters: {
            query?: {
                /** @description Dataset name (iris, wine, breast_cancer, digits) */
                name?: string | null;
                /** @description Proportion of dataset to use for test split */
                test_size?: number | null;
                /** @description Random seed for train/test split */
                random_state?: number | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatasetResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_parameters_api_knn_params_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": (components["schemas"]["SelectParameterInfo"] | components["schemas"]["IntParameterInfo"] | components["schemas"]["NumberParameterInfo"] | components["schemas"]["FloatParameterInfo"] | components["schemas"]["AnyParameterInfo"])[];
                };
            };
        };
    };
    predict_api_knn_predict_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KNNPredictionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KNNPredictionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    visualise_api_knn_visualise_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KNNVisualisationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KNNVisualisationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    train_api_knn_train_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KNNTrainingRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KNNTrainingResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_parameters_api_kmeans_params_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": (components["schemas"]["SelectParameterInfo"] | components["schemas"]["IntParameterInfo"] | components["schemas"]["NumberParameterInfo"] | components["schemas"]["FloatParameterInfo"] | components["schemas"]["AnyParameterInfo"])[];
                };
            };
        };
    };
    step_api_kmeans_step_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KMeansStepRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KMeansStepResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    train_api_kmeans_train_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KMeansTrainRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KMeansTrainResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    predict_api_kmeans_predict_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KMeansPredictRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KMeansPredictResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    health_check_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
}
